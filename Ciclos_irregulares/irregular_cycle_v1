# -*- coding: utf-8 -*-
"""
@author: Daniela
"""
from math import e
import rainflow as rf
import pandas as pd
import matplotlib.pyplot as plt

#Constantes 
AlphaSei = 5.75 * (10 **(-2))
BetaSei = 121

kT = 6.93 * (10 ** (-2))
Tref = 298
T = 298

kt = 4.14 * 10 ** (-10)
hr_cyc = 60 * 60 * 2 # dos horas en segundos (es lo que se demora en cargar y descargar un bateria)

kSigma = 1.04
sigmaRef = 0.8

kdelta1 =  1.40 * (10 ** (5))
kdelta2 = -5.01 * (10 ** (-1))
kdelta3 = -1.23 * (10 ** (5))

# Modelos:
# Factor de estrés de temperatura 
def stc(T):
  result = e ** (kT * (T - Tref) * (Tref/T))
  return result

# Factor de estrés de estado de carga SoC
def ssoc(sigma):
  result = e ** (kSigma * (sigma - sigmaRef))
  return result

# Factor de estrés de tiempo 
def st(t):
  result = kt * t
  return result

# Factor de estrés de profundidad de descarga DoD                     
def sd(delta):
  result = ((kdelta1 * (delta ** kdelta2)) + kdelta3) ** (-1)
  return result

#Función de tasa de degradación linealizada por ciclo
def F_d1(Sd, St, Ssoc, STc):
    result =(Sd + St) * Ssoc * STc
    return result

#Función para calcular la vida útil de la baterería
def L_cyc(N, fd1):
  result = 1 - AlphaSei * (e ** (-N * BetaSei * fd1)) - (1 - AlphaSei) * (e ** (-N * fd1))
  return result


list_L_cyc = []
list_L_cyc_L2=[100]
count = 0

df = pd.read_excel('SOC.xlsx')
(df.head())
#print(df)

t = df['time(s)']
soc = df['soc']

soc_rf = rf.count_cycles(soc)
#print(soc_rf)

prom = []
rango_a=[]
media=[]
cycle_count=[]

for rng, mean, conteo, start, end in rf.extract_cycles(soc):
    #print(rng,mean,conteo,start, end)
    
    rango_a.append(rng) # lista de valores de rango
    media.append(mean)
    cycle_count.append(conteo)
 
    delta = rng*2
    sigma = mean
    N = conteo
       
    Sd_valor = sd(delta)
    St_valor = st(hr_cyc)
    Ssoc_valor = ssoc(sigma)
    STc_valor = stc(T)
    
    F_d1_result = F_d1(Sd_valor,St_valor, Ssoc_valor,STc_valor)
    L_cyc_result = L_cyc(N, F_d1_result) 
    
    L = L_cyc_result
    L2= (list_L_cyc_L2[-1]/100-L)*100 # La batería cuando esta nueva es L=0  y esto se hace para representar la capacidad restante 
    #print(L2)
    #print(list_L_cyc_L2)
    list_L_cyc.append(L)
    list_L_cyc_L2.append(L2) # aquí se agregan los datos a la sublista
    count = count + 1  # se contabiliza el for
    
plt.subplots()
for i in range(len(list_L_cyc_L2)):
  plt.plot(i, list_L_cyc_L2[i], marker = '>', color = 'r')
plt.grid(axis = 'x', color = 'gray', linestyle = 'dashed')
plt.grid(axis = 'y', color = 'gray', linestyle = 'dashed')
plt.title('Envejecimiento ciclico para ciclos irregulares')
plt.xlabel('Números de ciclos')
plt.ylabel('Capacidad restante (%)')
plt.legend(loc = 'lower left')
plt.xlim(0,550)
plt.ylim(98,102)
plt.show()
